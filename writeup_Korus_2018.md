## Project: Kinematics Pick & Place
### Writeup Template: You can use this file as a template for your writeup if you want to submit it as a markdown file, but feel free to use some other method and submit a pdf if you prefer.

---


**Steps to complete the project:**  


1. Set up your ROS Workspace.
2. Download or clone the [project repository](https://github.com/udacity/RoboND-Kinematics-Project) into the ***src*** directory of your ROS Workspace.  
3. Experiment with the forward_kinematics environment and get familiar with the robot.
4. Launch in [demo mode](https://classroom.udacity.com/nanodegrees/nd209/parts/7b2fd2d7-e181-401e-977a-6158c77bf816/modules/8855de3f-2897-46c3-a805-628b5ecf045b/lessons/91d017b1-4493-4522-ad52-04a74a01094c/concepts/ae64bb91-e8c4-44c9-adbe-798e8f688193).
5. Perform Kinematic Analysis for the robot following the [project rubric](https://review.udacity.com/#!/rubrics/972/view).
6. Fill in the `IK_server.py` with your Inverse Kinematics code.


[//]: # (Image References)

[image1]: ./misc_images/misc1.png
[image2]: ./misc_images/misc3.png
[image3]: ./misc_images/misc2.png
[Frame_Model]: ./Images/Frame_Model2.png
[DH_coords]: ./Images/DH_coords.png
[DH_transform]: ./Images/DH_transform.png
[angles_WC]: ./Images/angles_WC.png
[Picking]: ./Images/Picking.png


## [Rubric](https://review.udacity.com/#!/rubrics/972/view) Points
### Here I will consider the rubric points individually and describe how I addressed each point in my implementation.  

---
### Writeup / README

#### 1. Provide a Writeup / README that includes all the rubric points and how you addressed each one.  You can submit your writeup as markdown or pdf.  

You're reading it!

### Kinematic Analysis
#### 1. Run the forward_kinematics demo and evaluate the kr210.urdf.xacro file to perform kinematic analysis of Kuka KR210 robot and derive its DH parameters.

The forward_kinematics demo provided a good overview of the joints and links of the kuka robot. For a better understanding of the URDF coordinat system I turned of the visual representation of the robots arm and only concentrated on the frames as shown in the figure below. From the frames I derived the different joint positions. The relative link position are equal to the joint positions in the _kr210.urdf.xacro_ file.

![alt text][Frame_Model]

The following table shows the extracted relative joint positions starting from the base-link and ending at the end-effector(EE)/Gripper(G). (The robot arm is in centered position)

Joints | x | y | z
--- | --- | --- | ---
BL | 0 | 0 | 0
J1 | 0 | 0 | 0.33
J2 | 0.35 | 0 | 0.42
J3 | 0 | 0 | 1.25
J4 | 0.96 | 0 | -0.054
J5 | 0.54 | 0 | 0
J6 | 0.193 | 0 | 0
EE/G | 0.11 | 0 | 0

The DH coordinate systems were placed as derived in the lecture and is shown in the following figure.

![alt text][DH_coords]


This way we get:


 * d1 = J1_z+J2_z; d4 = J4_x+J5_x; d7 = dG = J6_x + EE_x
 * a1 = J2_x; a2 = J3_z; a3 = J4_z
 * Rotiations of the coordinate systems are either by +90° or -90° (-pi/2, +pi/2)


 This yields the following DH-table.

 Links | alpha(i-1) | a(i-1) | d(i) | theta(i)
 --- | --- | --- | --- | ---
 0->1 (i=0)| 0 | 0 | 0.75 | q1
 1->2 (i=1)| - pi/2 | 0.35| 0 | -pi/2 + q2
 2->3 (i=2)| 0 | 1.25 | 0 | q3
 3->4 (i=3)| - pi/2 | -0.054 | 1.5 | q4
 4->5 (i=4)| pi/2| 0 | 0 | q5
 5->6 (i=5)| - pi/2 | 0 | 0 | q6
 6->EE (i=6)| 0 | 0 | 0.193 + 0.11 = 0.303 | 0


#### 2. Using the DH parameter table you derived earlier, create individual transformation matrices about each joint. In addition, also generate a generalized homogeneous transform between base_link and gripper_link using only end-effector(gripper) pose.

The DH transform is as derived in the lecture defined by

![alt text][DH_transform],

whereas i = 1..7 and 7 equals to the EE. Substituting with the values of the above DH table yields the transforms T0_1, T1_2, ..., T6_EE.

The generalized transform then is calculated by the combination of single transforms to

T0_EE = T0_1 * T1_2 * ... * T6_EE.




#### 3. Decouple Inverse Kinematics problem into Inverse Position Kinematics and inverse Orientation Kinematics; doing so derive the equations to calculate all individual joint angles.

The problem is separated in calculation of angles to the wrist center (at joint 4) and from the wrist center to the end effector.

The rotation matrices to the wrist center are taken from the defined transforms above. The rotation matrices are generated by the first three elements of the first three rows of a transformation matrix. R0_3

From wrist center to end effector thre rotation matrices are applied. Rotation around z-axis, then around y, axis, then around x axis.

To align the coordination systems for the end effector two correctional rotations are applied:

* a 180° rotation around the z-axis
* a -90° rotation around the y-axis

For calculation of the wrist centers position we take the endeffectors position and substract the relative position multiplied with the corrected rotations.

pos_WS = pos_EE - (d7 * ROT_corr)

For calculation of the angles I applied the arctangent. The distances I achieved by applying cosine and sinus law. Angles and sides are shown in the following picture.

![alt text][angles_WC]

This results in the following. The curly braces {a,b} denotes a distance between to points a and b.

* A = sqrt(d4² + a3²) ~ d4
* {2,x} = sqrt(WC_x² + WC_y²) - a1
* {2,y} = WC_y - d1  
* B = sqrt({2,x}² + {2,y}²)
* C = a2

a = acos((B² + C² - A²)/(2 * B * C ))
b = acos((A² +C² - B²)/(2 * A * C))

We get for the angles theta1 to theta 3

* theta 1 = atan2(y,x)
* theta2 = pi/2 - a - atan2({2,y}, {2,x})
* theta3 = pi/2 - (b + 0.036)

Those are substituted in the rotation matrices R0_3. Using the inverse of R0_3 and the rotation of the endeffector R_EE we achieve the remaining distances R3_6.

This gets theta 4 to theta 6 by

* theta4 = atan2(R3_6[2,2], -R3_6[0,2])
* theta5 = atan2(sqrt(R3_6[0,2] * R3_6[0,2] + R3_6[2,2] * R3_6[2,2]),R3_6[1,2])
* theta6 = atan2(-R3_6[1,1], R3_6[1,0])

,wheras [i,j] denotes the element in the ith row and jth column of R3_6.



### Project Implementation

#### 1. Fill in the `IK_server.py` file with properly commented python code for calculating Inverse Kinematics based on previously performed Kinematic Analysis. Your code must guide the robot to successfully complete 8/10 pick and place cycles. Briefly discuss the code you implemented and your results.


I basicly applied the methods as proposed in the lecture. Additionally cosine law was needed to get the distances for calculating the different angles.
In the forward kinematics part I put everything that needed to be calculated only once to achieve better performance.

Inside the loop the new matrices are constructed by substituting the variables corresponding to the values that are read in.

While the pic and place process works most of the time, it is still slow. This could be improved by directly typing all the calculated matrices and omit symbolic calculation.

Sometimes the wrist made several rotations before dumping the can. This could lead to loss of the can.

Also I noticed some drift. When running it for some time and then restart the pick up process, the centered position was off. Thus, the rover was going to a point right to the can and not pickup anithing anymore.

The result of the pickup and place process is shown in the screenshot below.


Screenshot of the Picking process:

![alt text][Picking]
